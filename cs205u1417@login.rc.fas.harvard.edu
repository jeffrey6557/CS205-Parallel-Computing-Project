
# coding: utf-8

# In[ ]:




# In[1]:

# % matplotlib inline
import numpy as np

import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display, HTML
import os



def preprocess_taq(name,freq=None):
    df = pd.read_csv('%s.csv'%name,parse_dates=[['DATE','TIME']])
    df.index = pd.to_datetime(df.DATE_TIME)
#     df = df[df['EX']=='Q'] # only nasdaq
    df = df[df.COND.isin("0,E,F,@F".split(',')+[""])] # only normal sales conditions

    df = df[['PRICE','SIZE']]
    df.columns = ['Adj Close','Volume'] # unadjusted close actually for TAQ
    if freq is None:
        price = df['Adj Close']#.resample('1T').ohlc()
        volume = df['Volume']#.resample('1T').sum()
        secs_df = pd.concat([price,volume],axis=1,join='inner')
    else:
        price = df['Adj Close'].resample(freq).ohlc()
        volume = df['Volume'].resample(freq).sum()
        secs_df = pd.concat([price,volume],axis=1,join='inner')
        secs_df.columns = 'Open,High,Low,Adj Close,Volume'.split(',')
    
    return secs_df

class technical_inputs(object):
    
    def __init__(self,source,cross_section=0):
        '''
        
        # module usage
        # tech = technical_inputs(source = 'stock')
        # tech.get_all_technical()[0]


        support source = etf, regional index, country index (requires ACC299.py and data files)
        or stock (requires GS2016_price.csv)  
    
        '''
        self.source = source
        self.cross_section = cross_section
       
        
        if (source=='etf') or (isinstance(source, list)):
            if (isinstance(source, list)):
                path = '/Users/liuchang/Desktop/Spring/CS205/Final Project/raw_data'
                os.chdir(path)
                # put all stocks in yahoo format in a list
                self.df_list,self.names = [preprocess_taq(name) for name in source],[i for i in source]
            else:
                self.df_list,self.names = ac.get_yahoo_etf(ohlc=1)
            if cross_section:
                self.price_df = pd.concat([self.df_list[i]['Adj Close'] for i in range(len(self.df_list))],axis=1,join='inner')

                self.volume_df = pd.concat([self.df_list[i]['Volume'] for i in range(len(self.df_list))],axis=1,join='inner')

                self.price_df.columns = self.names
                self.volume_df.columns = self.names

        elif source == 'regional index':
            self.df_list = [ ts for name,ts in ac.get_EQ_index()[0].iteritems()]
            self.price_df = ac.get_EQ_index()[0]
            self.names = [ts.name for ts in self.df_list]
        elif source == 'country index':
            self.price_df = ac.get_EQ_index()[1]
            self.df_list = [ ts for name,ts in ac.get_EQ_index()[1].iteritems()]
            self.names = [ts.name for ts in self.df_list]
        
            
            
            
    def get_all_technical(self,save=0):

        output_list =[]
        for df,name in zip(self.df_list,self.names):
            
            assert df.shape[0]!=0,'empty price info df'
            
            k = 50
            
            if self.source in ['regional index', 'country index']:
                price = df
                price = volume
                indicators = []
            else: 
                #  yahoo data format: Open High Low Close Volume Adj Close
                if self.source=='etf' or (isinstance(self.source,list)): 
                    price = df['Adj Close'].rename(name+'_price')
                    volume = df.Volume
               
                    indicators = [OBV(price,volume),
                             ROC(df, k)]
#                                  EOM(df,k)
    #                         STOK(df,k),
#                             STO(df,k),
#                             RSI(df,k),
#                             CCI(df,k)]
                   
                if self.cross_section:
                    # add cross-regional return 
                    indicators += [ADs(self.price_df, self.volume_df)]
                    
                    ret = self.price_df.pct_change().dropna()
                    ret.columns = ['RET_'+n for n in ret.columns]

                    price = pd.concat([price,ret],axis=1,join ='inner')
                
            
            
            

            
            indicators.extend([MA(price),
                        BIAS(price),
                        PSY(price)] + \
                        [ASY(price,kk) for kk in range(1,6)]+\
                        [EMA(price, kk) for kk in range(1,10,2)+range(10,60,5)] + \
                        [STD(price, kk) for kk in range(5,10)+[50,100,200]] + \
                         [disparity(price,k),
                         MOM(price, k)])
#                          LWR(df,k),
                         #ACCDIST(df, k)
                         
#             for ind in indicators:
#                         display(ind)
            for feature in indicators:
                try:
                    price = pd.concat([price,feature],axis=1)
                except Exception as e:
                    print e
                    continue

            
            output_list.append(price.dropna())

        return output_list
    
    def volume_summary(self):
        
        return self.volume_df.describe()
    
    def price_summary(self):
        return self.price_df
        

    

# In[8]:




def OBV(price,volume):
    thetas = price.diff().values
    obv = np.zeros(thetas.shape[0])
    thetas 
    for i, (theta, val) in enumerate(zip(thetas,volume)):
        if i ==0:
            continue
        if theta > 0 :
            obv[i] =  obv[i-1] + val 
        elif theta<0:
            obv[i] = obv[i-1] - val
        else:
            obv[i] = obv[i-1]
    ts = pd.Series(obv,index=price.index,name='OBV')
    return ts

def MA(price,k=5):
    ts = price.rolling(window=k).mean().rename('MA_%s'% k)
    return ts

def BIAS(price,k=6):
    ma = MA(price,k)

    return ((price-ma)/ma).rename('BIAS_%s'% k+ '_')

def PSY(price,k=12):
    A = price.diff() >0
    return A.rolling(window=k).mean().rename('PSY_%s'% k)
     
def ASY(price,k=5):
    try:
        log_ret = price.astype(float).apply(np.log).diff()
    except Exception as e:
        print e
        print price.astype(float).apply(np.log)
    return log_ret.rolling(window=k).mean().rename('ASY_%s'% k)

def STD(price, k=5):  
   
    a = price.rolling(window=k).std().rename('PRICE_STD_%s'%k)
    b = price.pct_change().rolling(window=k).std().rename('RET_STD_%s'%k) 
    return pd.concat([a,b],axis=1)

def disparity(price,k=5):
    res = price/MA(price,k)
    return res.rename('Disparity_%s'%k)

def LWR(df,k):
    low = df['Low'].rolling(window=k).min()
    high = df['Low'].rolling(window=k).max()
    res = (high - df['Adj Close'])/(high-low)
    return res.rename('LWR_%s'%k)

# the following indicators are adapted from:
# https://www.quantopian.com/posts/technical-analysis-indicators-without-talib-code

#Force Index  
def FORCE(df, n):  
    F = pd.Series(df['Adj Close'].diff(n) * df['Volume'].diff(n), name = 'Force_' + str(n))  
    return F  

#Ultimate Oscillator  
def ULTOSC(df):  
    i = 0  
    TR_l = [0]  
    BP_l = [0]  
    while i < df.index[-1]:  
        TR = max(df.ix[i + 1, 'High'], df.ix[i, 'Adj Close']) -        min(df.ix[i + 1, 'Low'], df.ix[i, 'Adj Close'])  
        TR_l.append(TR)  
        BP = df.ix[i, 'Adj Close'] - min(df.ix[i + 1, 'Low'], df.ix[i, 'Adj Close'])  
        BP_l.append(BP)  
        i = i + 1  
    UltO = pd.Series((4 * pd.rolling_sum(pd.Series(BP_l), 7) / pd.rolling_sum(pd.Series(TR_l), 7)) +                     (2 * pd.rolling_sum(pd.Series(BP_l), 14) / pd.rolling_sum(pd.Series(TR_l), 14)) +                      (pd.rolling_sum(pd.Series(BP_l), 28) / pd.rolling_sum(pd.Series(TR_l), 28)),
                     name = 'Ultimate_Osc')  
    return UltO

#Ease of Movement  
def EOM(df, n):  
    EoM = (df['High'].diff(1) + df['Low'].diff(1)) * (df['High'] - df['Low']) / (2 * df['Volume'])  
    Eom_ma = pd.Series(pd.rolling_mean(EoM, n), name = 'EoM_' + str(n))  
    return Eom_ma

def EMA(price, k):  
 
    return pd.ewma(price, span = k, min_periods = k ).rename('EMA' + str(k))  

#Momentum  
def MOM(price, k):  
    return pd.Series(price.diff(k), name = 'Momentum_' + str(k))  


#Accumulation/Distribution  
def ACCDIST(df, n):  
    ad = (2 * df['Adj Close'] - df['High'] - df['Low']) / (df['High'] - df['Low']) * df['Volume']  
    M = ad.diff(n - 1)  
    N = ad.shift(n - 1)  
    ROC = M / N  
    AD = pd.Series(ROC, name = 'Acc/Dist_ROC_' + str(n))  
    return AD  

#Rate of Change  
def ROC(df, n):  
    M = df['Adj Close'] 
    N = df['Adj Close'].shift(n)  
    return pd.Series(M / N, name = 'ROC_' + str(n))  

#Stochastic oscillator %K  
def STOK(df,k):  
    return pd.Series((df['Adj Close'] - df['Low'].rolling(window=k).min()) / 
                     (df['High'].rolling(window=k).max() - df['Low'].rolling(window=k).min()), name = 'SO%k')  
    

#Stochastic oscillator %D  
def STO(df, n):  
    SOk = pd.Series((df['Adj Close'] - df['Low'].rolling(window=n).min()) / 
                     (df['High'].rolling(window=n).max() - df['Low'].rolling(window=n).min()), name = 'SO%k')  
    SOd = pd.Series(pd.ewma(SOk, span = n, min_periods = n - 1), name = 'SO%d_' + str(n))  
    return SOd


#Relative Strength Index  
def RSI(df, n):  
    i = 0  
    UpI = [0]  
    DoI = [0]  
    while i + 1 <= df.shape[0]-1:  
        UpMove = df.ix[i + 1, 'High'] - df.ix[i, 'High']  
        DoMove = df.ix[i, 'Low'] - df.ix[i + 1, 'Low']
        if UpMove > DoMove and UpMove > 0:  
            UpD = UpMove  
        else: UpD = 0  
        UpI.append(UpD)  
        if DoMove > UpMove and DoMove > 0:  
            DoD = DoMove  
        else: DoD = 0  
        DoI.append(DoD)  
        i = i + 1  
    UpI = pd.Series(UpI)  
    DoI = pd.Series(DoI)  
    PosDI = pd.Series(pd.ewma(UpI, span = n, min_periods = n - 1))  
    NegDI = pd.Series(pd.ewma(DoI, span = n, min_periods = n - 1))  
    RSI = pd.Series(PosDI / (PosDI + NegDI), name = 'RSI_' + str(n),index = df.index)  
    return RSI
    

#Commodity Channel Index  
def CCI(df, n):  
    PP = (df['High'] + df['Low'] + df['Adj Close']) / 3  
    CCI = pd.Series((PP - PP.rolling(n).mean()) / PP.rolling(n).std(), name = 'CCI_' + str(n)) 
    return CCI


def ADs(price_df,volume_df):
    '''assume inputs are dfs with all the stocks' price and volume'''
    ups = price_df.diff()>0
    downs = price_df.diff()<0

    ad = ups.sum(axis=1) - downs.sum(axis=1)
    ad.name = 'AD'
    
    adv = ups.multiply(volume_df).sum(axis=1)-downs.multiply(volume_df).sum(axis=1)
    
    adv.name='ADV'
    
    adr = ups.multiply(volume_df).sum(axis=1)/downs.multiply(volume_df).sum(axis=1)
    adr = adr.replace([np.nan,np.inf],value=0)
    adr.name='log_ADR'
    
    # skewed and a lot of zeros; log transform + dummy values
    adr = np.log(adr+10**-5)

    return pd.concat([ad,adv,adr],axis=1).ix[1:,:]

a = technical_inputs(['AAPL_trades']) # return a list
a.get_all_technical()[0].to_csv('tick_level_inputs_AAPL2016.csv')


# In[ ]:

df
# secs_df.head()
    


# In[ ]:



